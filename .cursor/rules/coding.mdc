---
description:
globs: *.py
alwaysApply: false
---
# Coding Standards

This document defines **mandatory coding standards** that must be followed for all development activities, including adding, modifying, and refactoring code.

## SOLID Principles

The **SOLID principles** are the most fundamental and strict design guidelines to improve modular design, separation of concerns, extensibility, and maintainability. All developers must consistently adhere to them.

### Single Responsibility Principle

**A class should have only one reason to change.**
- "Responsibility" refers to the **reason to change** a module or class.
- This does not mean a class should do only one thing.
- It is not about grouping similar logic into one place. Rather, if a class has multiple reasons to change stemming from different concerns or stakeholders, those responsibilities should be separated into distinct modules.

---

### Open/Closed Principle

**Software entities should be open for extension, but closed for modification.**
- Open for extension means new functionality can be added by adding new code.
- Closed for modification means existing code should not be changed when adding new functionality.

---

### Liskov Substitution Principle

**Subtypes must be substitutable for their supertypes.**
- Instances of subtypes should behave in the same way as instances of their supertypes.
- A subtype refers to a class that inherits from a supertype.
- If replacing a supertype with a subtype causes unexpected behavior, inheritance should not be used.

---

### Interface Segregation Principle

**Clients should not be forced to depend on interfaces they do not use.**
- Clients should only be exposed to the methods they actually need.
- If a client ends up with unimplemented or unused methods, the interface should be split appropriately.

---

### Dependency Inversion Principle

**This principle consists of two rules:**

1. **High-level modules should not depend on low-level modules. Both should depend on abstractions.**
2. **Abstractions should not depend on details. Details should depend on abstractions.**

- "Dependency" here means one module uses functionality from another.
- High-level modules consume features, and low-level modules provide them.
- "Abstractions" refer to interfaces or abstract classes that define behavior independently of implementation (e.g., "save" is abstract, while "save to file" or "save to database" are details).
- Modules should depend on shared abstractions rather than on each other directly.

---

## GRASP (General Responsibility Assignment Software Patterns)

**GRASP** is a set of guidelines for assigning responsibilities in object-oriented design to promote flexibility and maintainability. It serves as a complementary foundation to the SOLID principles and should be followed as closely as possible by all developers.

---

### Information Expert

**Assign a responsibility to the class that has the necessary information to fulfill it.**

- The class that holds the relevant data is typically the best place for the corresponding behavior.
- This encourages data encapsulation and reduces coupling.

---

### Creator

**A class B should create an instance of class A if there is a strong relationship between them.**

Class B is considered the creator of A if any of the following conditions apply:
- B aggregates A (has-a relationship)
- B holds a reference to A
- B has the initialization data for A
- B controls the lifecycle of A
- B frequently uses A

---

### Controller

**System events should be handled by a controller, not by the UI.**

- The controller should not directly interact with UI elements or user interfaces.

---

### Low Coupling

**Minimize dependencies between classes wherever possible.**

---

### High Cohesion

**Each class should have highly related and focused responsibilities.**

---

### Polymorphism

**Use polymorphism to handle behavioral variations via abstract classes or interfaces, and implement specific behaviors in subclasses.**

- Promotes maintainability and extensibility.
- Closely aligned with the Liskov Substitution Principle.

---

### Pure Fabrication

**Introduce abstract classes to balance cohesion and coupling.**

- High cohesion and low coupling often conflict.
- To resolve this, create additional abstract classes that centralize related responsibilities without overly coupling other classes.

---

### Indirection

**Introduce a mediator class to avoid strong direct dependencies between two classes.**

- This promotes loose coupling.

---

### Protected Variations

**Encapsulate areas of instability behind stable interfaces to protect against changes.**

- This creates a structure that is resilient to changes in implementation details.
